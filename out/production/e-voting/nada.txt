    //private final String MULTICAST_ADDRESS = "224.3.2.3";
    //private MulticastSocket mSocket;
    //private static ArrayList<String> multicastServers = new ArrayList<>();
    //private static DatagramSocket dSocket;
    //private static boolean run = true;
    //private static checkServers check = new checkServers();

    /*public void ping() {
        System.out.println("Ping recebido");
    }*/

    /**
     * Função para enviar pacote p multicast
     * @param s
     */
    //Função para enviar pacote p multicast
    /*public void enviarPacote(String s) {
        try {
            MulticastSocket socket = new MulticastSocket();
            InetAddress group = InetAddress.getByName(MULTICAST_ADDRESS);
            socket.joinGroup(group);

            byte[] buffer = s.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(MULTICAST_ADDRESS), PORT);
            socket.send(packet);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }*/

    /**
     * Função para receber pacote do multicast
     * @return
     */
    //Função para receber pacote do multicast
    /*public String recebePacote() {

        byte[] buffer = new byte[2000];
        DatagramPacket message = new DatagramPacket(buffer, buffer.length);
        while (true) {
            try {
                mSocket.setSoTimeout(40000);
            } catch (SocketException e) {
                e.printStackTrace();
            }
            try {
                mSocket.receive(message);
                System.out.println("Mensagem: " + message.toString());
                break;
            } catch (IOException e) {
                //mSocket.close();
                //return "Ocorreu um problema, tente mais tarde.";
            }
        }
        return new String(message.getData(), 0, message.getLength());
    }*/


    /**
     * Função que faz print quando servidor começa a correr e inicia checkservers, que irá verificar servidores multicast ativos
     * @throws RemoteException
     */
    /*public void sayHello() throws RemoteException {
        System.out.println("Servidor a correr");

    }*/

/*
            // RMI SERVER SECUNDÁRIO
            boolean verificaFail = true;
            while (verificaFail) {
                verificaFail = false;

                try {
                    Thread.sleep(500);
                    LocateRegistry.createRegistry(PORT_r).rebind("RMI_Server", rmis);
                    //run = false;
                    //System.out.println("Connected! Server Backup assumed");

                    //run = true;
                    //check = new checkServers();
                    //check.start();

                } catch (InterruptedException e) {
                    System.out.println("Main RMI Server working... Waiting for failures");
                    verificaFail = true;
                    e.printStackTrace();
                }
            }*/

/*private static class checkServers extends Thread {
        @Override
        public void run() {
            while (run){
                multicastServers=checkActiveMulticastServers();
                try {
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            }
        }
    }*/

    /**
     * Funçao que verifica que servers multicast estao online atraves do envio e rececao de pacotes
     * @return
     */
    //Funçao que verifica que servers multicast estao online atraves do envio e rececao de pacotes
    /*public static ArrayList<String> checkActiveMulticastServers() {
        String s = "server !! 0 ; type ! checkIfOn ; ";
        try {
            MulticastSocket socket = new MulticastSocket();
            InetAddress group = InetAddress.getByName("224.3.2.3");
            socket.joinGroup(group);
            System.out.println("Demora");
            byte[] buffer = s.getBytes();
            DatagramPacket packet = new DatagramPacket(buffer, buffer.length, InetAddress.getByName("224.3.2.3"), PORT);
            socket.send(packet);
            System.out.println("done");

        } catch (IOException e) {
            e.printStackTrace();
        }
        nSocket = null;

        try {
            nSocket = new DatagramSocket(4372);
        } catch (SocketException e) {
            e.printStackTrace();
        }
        ArrayList<String> arrayList = new ArrayList<>();
        byte[] buffer = new byte[1000];
        DatagramPacket request = new DatagramPacket(buffer, buffer.length);
        while (true) {

            try {

                nSocket.receive(request);
                String temp = new String(request.getData(), 0, request.getLength());
                String[] split = temp.split(" !! ");
                arrayList.add(split[1]);
                break;
            } catch (IOException e) {
                nSocket.close();

            }


        }
        nSocket.close();
        return arrayList;
    }*/

    /**
     * Escolhe ao acaso que server multicast utilizar
     * @return
     */
    //Escolhe ao acaso que server multicast utilizar
    /*public String chooseMulticastServer() {
        int max = multicastServers.size()-1;
        int min = 0;
        int n = (int) Math.floor(Math.random() * ((max - min) + 1) + min);

        System.out.println("Escolheu o servidor "+ multicastServers.get(n));


        return multicastServers.get(n);
    }*/